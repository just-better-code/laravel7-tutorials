<h2>Введение</h2>
<p>Здравствуйте дорогие Хабровчане.<br>
    В ходе своей работы над api-платформой я провел много времени в поисках верного пути авторизации действий пользователя. Задача была поставлена такая - создать довольно разветвленную систему контроля доступа и действий.
    При этом большинство из них на обычный CRUD, но необходимо будет авторизировать и другие действия контролера.
    А значит необходимо создать простую и в то же время эффективную и гибкую систему. Шишек было набито немало, потому в этих статьях я решил продемонстрировать несколько упрощенную версию того что у меня получилось.
</p>
<p>
    Отдельно хотелось-бы добавить - материал расчитан на практикующих программистов, и будет сложен для понимания начинающему свой путь разработчику. В данной статье не будет расписано установки проекта, и настройки подключения к БД. Все это вы без труда найдете на просторах интернета.
</p>
<cut/>
<h2>Часть 1. Модель, Контроллеры</h2>

<p>Итак, задача: Имеется много моделей, количество которых может увеличиваться, и уменьшаться по ходу развития проекта.
    Действия над каждой из них должно авторизоваться по ролях.
    Присутствуют и простые действия, такие как CRUD, и дополнительные (к примеру <i>import, export</i>).
    Необходимо максимально упростить работу разработчику (себе любимому) для внесения дополнительных моделей и методов к ним.
    В статье приводится пример для Api приложения, но решение подходит не только для такового.
</p>
<h3>Модель</h3>
<p>
    Для демонстрации создадим модель <i>Post</i>. Я предпочитаю отойти от не целесообразной (в нашем случае) практики хранения моделей в корне папки app.
    Потому создаю Папку <i>app/Models</i> а в ней модель Posts. (Предполагается что моделей будет достаточно много, иначе зачем тогда весь сыр-бор).
    К модели создаем таблицу. Для этого консоли выполняем команды:
</p>
<pre>
    php artisan make:model Models/Post --api --migration
    php artisan migrate
</pre>
<p>В результате мы получим стандартные: модель, миграцию и контроллер. На модели и миграции останавливаться не стоит, так как в рамках данной статьи их я изменять не буду.</p>
<h3>Контроллер</h3>
<p>
    Мы уже имеем згенерированый контроллер <i>PostController</i> с базовыми CRUD операциями, и стандартный родительский класс <i>Controller</i>.
    Еще нам понадобится содать абстрактный класс <i>ModelController</i> который расширит клас <i>Controller</i> и от которого, в свою очередь,  унаследуем наш <i>PostController</i>.
    В сам же <i>PostController</i> для демонстрации добавим еще два метода - <i>import()</i> и <i>export(Post $post)</i>.
    Я не стану останавливаться на действиях над ресурсами, так как это не есть предметом статьи.
</p>
<h4>А сейчас немного теории</h4>
<p>
    В Laravel существует стандартный трейт <i>Illuminate\Foundation\Auth\Access\AuthorizesRequests</i>.
    В нашем случае он расширяет стандартный клас контроллера <i>App\Http\Controllers\Controller</i> от которого мы унаследуем свой <i>ModelController</i>. Сам же <i>Controller</i> я сознательно изменять не буду, так как попытка перезаписывать методы трейта в стандартном контроллере приведет к ошибке во время исполнения.
    Этот трейт в своем арсенале имеет метод <i>authorizeResource($model)</i>.
    Он может принимать аргументом строковое имя класса, и генерировать соответствующие посредники (<i>Middleware</i>) для доступа к методам контроллера.
    Забегая немного наперед продемонстрирую вам пример генерируемых посредников:
</p>
<pre>
    can:viewAny,App\Models\Post
    can:view,post
    can:update,post
</pre>
<p>Как вы, возможно, заметили - здесь есть две особенности:</p>
<ol>
    <li>Методов <i>viewAny</i> и <i>view</i> в классе <i>PostController</i> не существует в стандартных методах класов типа <i>apiResource</i></li> (пример класса ниже)
    <li>В одном случае используется имя класса, в других - экземпляра модели.</li>
</ol>
<p>
    Об этом по порядку:
</p>
<p>
    Первое. Для определения соответствия метода контроллера и значения в аргументе посредника существует стандартный метод <i>resourceAbilityMap()</i> Он и задает это соответствие.
</p>
<source lang="php">
<?php
protected function resourceAbilityMap()
{
    return [
        'index' => 'viewAny',
        'show' => 'view',
        'create' => 'create',
        'store' => 'create',
        'edit' => 'update',
        'update' => 'update',
        'destroy' => 'delete',
    ];
}
</source>
<p>
    Второе. В Laravel существует два типа авторизации действий. Действие с экземпляром модели, и действие без экземпляра модели. К примеру метод просмотра списка index() не имеет экземпляра модели, а метод show(Post $post) имеет. Для определения соответствия фремворк использует метод <i>resourceMethodsWithoutModels()</i>
</p>
<source lang="php">
<?php
protected function resourceMethodsWithoutModels()
{
    return ['index', 'create', 'store'];
}
</source>
<h4>Перейдем к практике</h4>
<h5>Базовый контроллер (ModelController)</h5>
<p>В директории <i>app/Http/Controllers</i> Создаем абстрактный класс <i>ModelController</i>. В нем определяем следующее:</p>
<ul>
    <li>
        Свойство <i>$guardedMethods</i> содержит в себе список пар значений "метод контроллера" => "метод политики".
        О методах политики(Policy) подробней будет написано во второй части статьи, и все же стоит уточнить, что на самом деле это имя Шлюза(Gate). Но в конечном итоге мы придем именно к тому что здесь будет записываться метод политики.
    </li>
    <li>
        Свойство <i>$methodsWithoutModels</i> содержит в себе список методов которые не имеют экземпляра модели.
    </li>
    <li>
        Абстрактный метод <i>getModelClass()</i> обязует программиста определить в дочернем контроллере соответствующий метод.
        Это даст нам нам возможность использовать его в качестве аргумента для метода авторизации ресурсов.
    </li>
    <li>
        Конструктор посредством метода <i>authorizeResource($this->getModelClass())</i> запускает генерацию посредников для защиты методов. (Точнее для защиты путей(Route), но это уже нюансы)
    </li>
    <li>
        Методы <i>resourceAbilityMap()</i> и <i>resourceMethodsWithoutModels()</i> функциональность которых описана выше, с той лишь разницей, что наши методы будут дополнять стандартные значения.
    </li>
</ul>
<source lang="php">
<?php

namespace App\Http\Controllers;

abstract class ModelController extends Controller
{
    /** @var array 'method' => 'policy'*/
    protected $guardedMethods = [];

    protected $methodsWithoutModels = [];

    protected abstract function getModelClass(): string;

    public function __construct()
    {
        $this->authorizeResource($this->getModelClass());
    }

    protected function resourceAbilityMap()
    {
        $base = parent::resourceAbilityMap();

        return array_merge($base, $this->guardedMethods);
    }

    protected function resourceMethodsWithoutModels()
    {
        $base = parent::resourceMethodsWithoutModels();

        return array_merge($base, $this->methodsWithoutModels);
    }
}
</source>
<h5>Контроллер модели (PostController)</h5>
<p>Контроллер модели будет содержать в себе следущее:</p>
<ul>
    <li>Определение метода <i>getModelClass()</i> который должен отдавать строковое имя класса модели.</li>
    <li>Свойство <i>$methodsWithoutModels</i> в котором запишем пары значений "метод контроллера" => "метод политики" для дополнительных методов. Стандартные методы уже учтены. Здесь стоит отметить что даные пары значений можно называть по разному, но я для удобства предлагаю называть по принципу ключ=значение. Данную реализацию можно еще улучшить путем автоматической генерации даных пар, но это уже вам виднее, в зависимости от задачи.</li>
    <li>Свойство <i>$methodsWithoutModels</i> в котором запишем имена дополнительных методов, которые не оперируют экземпляром модели. В нашем случае <i>import</i></li>
    <li>Что-бы было более понятно - я подписал какие именно методы имеют экземпляр модели, а какие нет. Повторюсь - действия внутри методов контроллера не входят в тематику этой статьи.</li>
</ul>
<source lang="php">
<?php

namespace App\Http\Controllers;

use App\Models\Post;
use Illuminate\Http\Request;

class PostController extends ModelController
{
    /** @var array 'method' => 'policy'*/
    protected $guardedMethods = [
        'export' => 'export',
        'import' => 'import',
    ];

    protected $methodsWithoutModels = ['import'];

    protected function getModelClass(): string
    {
        return Post::class;
    }

    public function index()
    { /** Не имеет экземпляра модели */ }

    public function create()
    { /** Не имеет экземпляра модели */ }

    public function store(Request $request)
    { /** Имеет экземпляр модели */ }

    public function show(Post $post)
    { /** Имеет экземпляр модели */ }

    public function edit(Post $post)
    { /** Имеет экземпляр модели */ }

    public function update(Request $request, Post $post)
    { /** Имеет экземпляр модели */ }

    public function destroy(Post $post)
    { /** Имеет экземпляр модели */ }

    public function import()
    { /** Не имеет экземпляра модели */ }

    public function export(Post $post)
    { /** Имеет экземпляр модели */ }
}
</source>


<h3>Пути (Routes)</h3>
<p>
    Настало время открыть доступ к нашим методам.
    Переходим к файлу 'routes/api.php' (или 'routes/web.php', в зависимости от задачи) и прописываем там доступ к методам.
    И несмотря на то что эта задача достаточно тривиальна, все-же стоит отметить два нюанса.
    Первый - предпочтительно (а в нашем случае необходимо) располагать ваши дополнительные пути выше стандартных, генерируемых методом Route::apiResource('posts', 'PostController'). Это обусловлено принципом маршрутизации Laravel. Более частные случаи нужно разполагать выше общих.
    Второй - вовсе не обязательно прописывать посредника 'auth:api'. Система авторизации вполне может работать и по принципах не зависящих от аутентификации пользователя.
</p>
<source lang="php">
<?php

use App\Http\Controllers\PostController;
use Illuminate\Support\Facades\Route;

Route::group(['middleware' => ['auth:api']], static function () {
    Route::post('posts/import', 'PostController@import')->name('posts.import');
    Route::get('posts/{post}/export', 'PostController@export')->name('posts.export');
    Route::apiResource('posts', 'PostController');
});
</source>
<p>А сейчас проверим все ли правильно сделали. В консоли выполняем команду:</p>
<pre>php artisan route:list</pre>
<p>Если все сделано верно - видим результат (я сократил таблицу до необходимомого минимума)</p>
<pre>
+-------------------------+----------------------------+---------------------------------+
| URI                     | Action                     | Middleware                      |
+-------------------------+----------------------------+---------------------------------+
| api/posts               | ...\PostController@index   | ...,can:viewAny,App\Models\Post |
| api/posts               | ...\PostController@store   | ...,can:create,App\Models\Post  |
| api/posts/import        | ...\PostController@import  | ...,can:import,App\Models\Post  |
| api/posts/{post}        | ...\PostController@show    | ...,can:view,post               |
| api/posts/{post}        | ...\PostController@update  | ...,can:update,post             |
| api/posts/{post}        | ...\PostController@destroy | ...,can:delete,post             |
| api/posts/{post}/export | ...\PostController@export  | ...,can:export,post             |
+-------------------------+----------------------------+---------------------------------+
</pre>
<p><strong>Следующий этап - настройка связки Шлюз(Gate)<->Политика(Policy). Но об этом уже во второй части.</strong></p>